const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

const achievements = mongoose.model("achievements");
const users = mongoose.model("users");


// ACHIEVEMENTS PAGE
/**
 * Here the server will recognise that the server is requested with the /achievements URL and will render the achievements file.
 * The server will also serve the user's achievements to the page in json format.
 * If the user is not logged in, they will be redirected to the login page.
 */
router.get("/", async (req, res) => {
  if (!req.session.uid) return res.redirect("/login");

  try {
    const user = await users.findById(req.session.uid);
    const activeAchievements = await achievements.find({
      _id: { $in: user.activeAchievements },
    });
    const inactiveAchievements = await achievements.find({
      _id: { $in: user.inactiveAchievements },
    });

    res.render("achievements", {
      user,
      activeAchievements,
      inactiveAchievements,
    });
  } catch (err) {
    console.error("Error loading achievements:", err);
    res.status(500).send("Server error");
  }
});


// Route to get achievement data
router.get("/data", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const user = await users.findById(req.session.uid);

  // Fetch active and inactive achievements
  const allActive = await Promise.all(user.activeAchievements.map(id => achievements.findById(id)));
  const allInactive = await Promise.all(user.inactiveAchievements.map(id => achievements.findById(id)));

  const active = allActive.filter(a => a && !a.completed);
  const completedFromActive = allActive.filter(a => a && a.completed);

  // Create a set of IDs that are already included
  const knownIds = new Set([
    ...user.activeAchievements.map(id => id.toString()),
    ...user.inactiveAchievements.map(id => id.toString()),
  ]);

  // Fetch additional completed achievements NOT tracked in active/inactive
  const extraCompleted = await achievements.find({
    completed: true,
    userId: user._id,
    _id: { $nin: Array.from(knownIds) }
  });

  const completed = [...completedFromActive, ...extraCompleted];

  res.json({
    active,
    inactive: allInactive.filter(Boolean),
    completed
  });
});


/**
 * Fetches the users achievements from the database, along with their user information.
 * Uses the user's ID stored in the session to find the user in the database where the achievements are stored.
 * The achievements are identified and delivered to the view.
 * The user information is also delivered to the view.
 */
router.post("/", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const userAchievements = await achievements.find({
      _id: { $in: user.achievements },
    });
    console.log("Fetched Achievements:", userAchievements);
    result.json({ achievements: userAchievements, user: user });
  } catch (err) {
    console.log("Error fetching achievements:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Updates the achievement that is passed by the script in the view.
 * The achievement is identified by its ID and the new data is passed to the database.
 * The achievement is updated in the database, with the new progress, completed and date and previousDate values.
 */
router.post("/update", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const achievementId = request.body.achievementId;
    const progress = request.body.progress;
    const completed = request.body.completed;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    await achievements.findByIdAndUpdate(achievementId, {
      progress,
      completed,
      date,
      previousDate,
    });
    console.log("Updated Achievement:", achievementId);
    result.json({ message: "Achievement updated successfully" });
  } catch (err) {
    console.log("Error updating achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Replace's an achievement with a new one.
 * The new achievement is created from the mongoDB achievements model, and populated with the new data passed to the server.
 * The new achievement is saved to the database and the user's achievements array.
 * The old achievement is deleted, and its id removed from user's achievements array, and the reward is returned to the view.
 */
router.post("/replace", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const type = request.body.type;
    const description = request.body.description;
    const progress = request.body.progress;
    const target = request.body.target;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const completed = request.body.completed;
    const reward = request.body.reward;
    const oldID = request.body.oldID;
    const newAchievement = new achievements({
      userId: request.session.uid,
      type,
      description,
      progress,
      target,
      date,
      previousDate,
      completed,
      reward,
    });
    await newAchievement.save();
    await users.findByIdAndUpdate(request.session.uid, {
      $push: { achievements: newAchievement._id },
    });
    const oldReward = await achievements.findById(oldID);
    await achievements.findByIdAndDelete(oldID);
    await users.findByIdAndUpdate(request.session.uid, {
      $pull: { achievements: oldID },
    });
    console.log("Replaced and achievement with:", newAchievement);
    result.json({ reward: oldReward.reward });
  } catch (err) {
    console.log("Error replacing achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

router.post("/activate", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  const { id } = req.body;

  try {
    const user = await users.findById(req.session.uid);

    if (user.activeAchievements.length >= 4) {
      return res.status(400).json({ error: "You can only have 4 active achievements." });
    }

    // Check if achievement exists in inactiveAchievements (make sure users can't double click quickly)
    const index = user.inactiveAchievements.indexOf(id);
    if (index === -1) {
      return res.status(404).json({ error: "Achievement not found in inactive list." });
    }

    // Move it from inactive to active
    user.inactiveAchievements.splice(index, 1);
    user.activeAchievements.push(id);
    await user.save();

    // Track "add_achievement" progress for "Select an inactive achievement" achievement
    const addAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "add_achievement",
      completed: false,
    });

    // If the 'add_achievement' achievement type exists for the user, and it hasnâ€™t reached its target yet, then increase its progress by 1
    if (addAchievement && addAchievement.progress < addAchievement.target) {
      addAchievement.progress += 1;
      await addAchievement.save();
    }

    res.json({ success: true });
  } catch (err) {
    console.error("Error activating achievement:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

router.get("/templates", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  try {
    const templates = await achievementTemplates.find({});
    res.json({ templates });
  } catch (err) {
    console.error("Error fetching templates:", err.message);
    res.status(500).json({ error: "Failed to load templates" });
  }
});


// Route to redeem achievement
router.post("/redeem", async (req, res) => {
  if (!req.session.uid) {
    return result.redirect("/login");
  }
  const { id } = req.body;

  try {
    // Fetch user
    const user = await users.findById(req.session.uid);

    // Fetch achievement
    const achievement = await achievements.findById(id);
    if (!achievement) {
      return res.status(404).json({ error: "Achievement not found" });
    }

    // Add userID to achievement
    if (!achievement.userId) {
      achievement.userId = req.session.uid;
    }
    
    // Set achievement as completed
    achievement.completed = true;
    await achievement.save();

    // Remove redeemed achievement from activeAchievements
    user.activeAchievements = user.activeAchievements.filter(aid =>
      aid && aid.toString() !== achievement._id.toString()
    );

    // Add reward to user coins balance
    user.coins += achievement.reward;
    await user.save();

    res.json({ reward: achievement.reward });
  } catch (err) {
    console.error("Error redeeming achievement:", err.message);
    res.status(500).json({ error: "Could not redeem reward" });
  }
});

module.exports = router;