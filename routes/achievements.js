const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

const achievements = mongoose.model("achievements");
const users = mongoose.model("users");


// ACHIEVEMENTS PAGE
/**
 * Here the server will recognise that the server is requested with the /achievements URL and will render the achievements file.
 * The server will also serve the user's achievements to the page in json format.
 * If the user is not logged in, they will be redirected to the login page.
 */
router.get("/", async (req, res) => {
  if (!req.session.uid) return res.redirect("/login");

  try {
    const user = await users.findById(req.session.uid);
    const activeAchievements = await achievements.find({
      _id: { $in: user.activeAchievements },
    });
    const inactiveAchievements = await achievements.find({
      _id: { $in: user.inactiveAchievements },
    });

    res.render("achievements", {
      user,
      activeAchievements,
      inactiveAchievements,
    });
  } catch (err) {
    console.error("Error loading achievements:", err);
    res.status(500).send("Server error");
  }
});


// Route to get achievement data
router.get("/data", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const user = await users.findById(req.session.uid);
  // Preserve same order as user.activeAchievements
  const allActive = await Promise.all(
    user.activeAchievements.map(id => achievements.findById(id)));
  // Preserve same order as user.inactiveAchievements
  const allInactive = await Promise.all(
    user.inactiveAchievements.map(id => achievements.findById(id)));

  // Split active into completed and not completed
  const active = allActive.filter(a => !a.completed);
  const completed = allActive.filter(a => a.completed);

  res.json({
    active,
    inactive: allInactive,
    completed
  });
});

/**
 * Fetches the users achievements from the database, along with their user information.
 * Uses the user's ID stored in the session to find the user in the database where the achievements are stored.
 * The achievements are identified and delivered to the view.
 * The user information is also delivered to the view.
 */
router.post("/", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const userAchievements = await achievements.find({
      _id: { $in: user.achievements },
    });
    console.log("Fetched Achievements:", userAchievements);
    result.json({ achievements: userAchievements, user: user });
  } catch (err) {
    console.log("Error fetching achievements:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Updates the achievement that is passed by the script in the view.
 * The achievement is identified by its ID and the new data is passed to the database.
 * The achievement is updated in the database, with the new progress, completed and date and previousDate values.
 */
router.post("/update", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const achievementId = request.body.achievementId;
    const progress = request.body.progress;
    const completed = request.body.completed;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    await achievements.findByIdAndUpdate(achievementId, {
      progress,
      completed,
      date,
      previousDate,
    });
    console.log("Updated Achievement:", achievementId);
    result.json({ message: "Achievement updated successfully" });
  } catch (err) {
    console.log("Error updating achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Replace's an achievement with a new one.
 * The new achievement is created from the mongoDB achievements model, and populated with the new data passed to the server.
 * The new achievement is saved to the database and the user's achievements array.
 * The old achievement is deleted, and its id removed from user's achievements array, and the reward is returned to the view.
 */
router.post("/replace", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const type = request.body.type;
    const description = request.body.description;
    const progress = request.body.progress;
    const target = request.body.target;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const completed = request.body.completed;
    const reward = request.body.reward;
    const oldID = request.body.oldID;
    const newAchievement = new achievements({
      type,
      description,
      progress,
      target,
      date,
      previousDate,
      completed,
      reward,
    });
    await newAchievement.save();
    await users.findByIdAndUpdate(request.session.uid, {
      $push: { achievements: newAchievement._id },
    });
    const oldReward = await achievements.findById(oldID);
    await achievements.findByIdAndDelete(oldID);
    await users.findByIdAndUpdate(request.session.uid, {
      $pull: { achievements: oldID },
    });
    console.log("Replaced and achievement with:", newAchievement);
    result.json({ reward: oldReward.reward });
  } catch (err) {
    console.log("Error replacing achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

router.post("/activate", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  const { id } = req.body;

  try {
    const user = await users.findById(req.session.uid);

    if (user.activeAchievements.length >= 4) {
      return res.status(400).json({ error: "You can only have 4 active achievements." });
    }

    // Check if achievement exists in inactiveAchievements
    const index = user.inactiveAchievements.indexOf(id);
    if (index === -1) {
      return res.status(404).json({ error: "Achievement not found in inactive list." });
    }

    // Move it from inactive to active
    user.inactiveAchievements.splice(index, 1);
    user.activeAchievements.push(id);
    await user.save();

    // Track "add_achievement" progress for "Select an inactive achievement" achievement
    const addAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "add_achievement",
      completed: false,
    });

    // If the 'add_achievement' achievement type exists for the user, and it hasnâ€™t reached its target yet, then increase its progress by 1
    if (addAchievement && addAchievement.progress < addAchievement.target) {
      addAchievement.progress += 1;
      await addAchievement.save();
    }

    res.json({ success: true });
  } catch (err) {
    console.error("Error activating achievement:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

router.get("/templates", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  try {
    const templates = await achievementTemplates.find({});
    res.json({ templates });
  } catch (err) {
    console.error("Error fetching templates:", err.message);
    res.status(500).json({ error: "Failed to load templates" });
  }
});


// Route to redeem achievement
router.post("/redeem", async (req, res) => {
  if (!req.session.uid) {
    return result.redirect("/login");
  }
  const { id } = req.body;

  try {
    const achievement = await achievements.findById(id);
    // Set achievement as completed
    achievement.completed = true;
    await achievement.save();

    // Retrieve reward and add to user coins balance
    const user = await users.findById(req.session.uid);
    user.coins += achievement.reward;
    await user.save();

    res.json({ reward: achievement.reward });
  } catch (err) {
    console.error("Error redeeming achievement:", err.message);
    res.status(500).json({ error: "Could not redeem reward" });
  }
});

module.exports = router;