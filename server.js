const express = require("express");
const mongoose = require("mongoose");
const bcrypt = require("bcrypt");
const session = require("express-session");
const favicon = require("serve-favicon");
const path = require("path");
const axios = require("axios");
const { type } = require("os");
const OpenAI = require("openai");

/**
 * Require dotenv to load environment variables from a .env file for security.
 * This will allow secret keys to be stored in a .env file instead of hardcoded in the code.
 * The file is not included in the repository and is added to the .gitignore file.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
require("dotenv").config();
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

const app = express();

/**
 * Set the port to the environment variable or default to 3000.
 * This allows the server to run on different ports depending on the environment.
 * This is useful for deployment and testing.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
const PORT = process.env.PORT || 3000; // Set the port to the environment variable or default to 3000
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Set EJS as the view engine
app.set("view engine", "ejs");
app.set("views", __dirname + "/views"); // Set the views directory

/**
 * Middleware to parse JSON and handle sessions, and URL-encoded data parsing, and serve static files.
 * This middleware is used to parse incoming JSON requests and manage user sessions. It also helps serve static files like photo's.
 * This is important for handling form submissions and user authentication, as well as helping the server to serve static files like CSS, JS, and images.
 *
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
// Middleware to parse JSON
app.use(express.json());

// Middleware to serve static files (CSS, JS, images)
app.use(express.static("public"));

// Middleware to use favicon
// app.use(express.favicon(__dirname + '/public/images/favicon.png'));
app.use(favicon(path.join(__dirname, "public", "images", "favicon.png")));

// Middleware to parse URL-encoded form data
app.use(express.urlencoded({ extended: true }));

// Middleware for sessions
app.use(
  session({
    secret: process.env.SECRETKEY,
    resave: false,
    saveUninitialized: true,
    cookie: { maxAge: 86400000 },
  })
);
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// Database connection
mongoose
  .connect(process.env.MONGO_STRING, {
    /**
     * Setting's for database connection
     * With these settings, we can avoid deprecation warnings and ensure a more stable connection.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    useNewUrlParser: true,
    useUnifiedTopology: true,
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  })
  .then(() => {
    console.log("Connected to database successfully!");
  })
  .catch((err) => {
    console.log("Error connecting to database:", err.message);
  });


/** This is the schema for users, it acts as a template for models to use when creating new documents in the database.
 *  Transaction ID's are included in the user schema.
 *  Pets are included in the user schema.
 */
const userSchema = new mongoose.Schema({
  username: String,
  password: String,
  categories: Array,
  balance: Number,
  transactions: Array,
  // Generated by ChatGPT -4o
  activeAchievements: [
    { type: mongoose.Schema.Types.ObjectId, ref: "achievements" },
  ],
  inactiveAchievements: [
    { type: mongoose.Schema.Types.ObjectId, ref: "achievements" },
  ],
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  inventory: Array,
  pet: {
    base: String,
    item: String,
    happiness: Number,
  },
  date: Date,
  budget: {
    weekly: Number,
    monthly: Number,
  },
  coins: Number,
});


/**
 * This is the schema for transactions, it acts as a template for models to use when creating new documents in the database.
 * Transactions are tied to users in there user schema by thier model ID.
 * The server automatically adds the transaction ID to the user schema when a new transaction is created.
 */
const transactionSchema = new mongoose.Schema({
  name: String,
  category: String,
  date: Date,
  amount: Number,
  comments: String,
  type: String,
});


/**
 * This is the schema for achievements, it acts as a template for models to use when creating new documents in the database.
 * Achievements are tied to users in there user schema by thier model ID.
 * The server automatically adds the achievement ID to the user schema when a new achievement is created.
 */
const achievementSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'users'
  },
  type: String,
  description: String,
  progress: Number,
  target: Number,
  date: Date,
  previousDate: Date,
  completed: Boolean,
  reward: Number,
});

// Here we create a model for the achievement schema, this will be used to make our collection in the database.
const achievements = mongoose.model("achievements", achievementSchema);

// Here we create a model for the user schema, this will be used to make our collection in the database.
const users = mongoose.model("users", userSchema);

// Here we create a model for the transaction schema, this will be used to make our collection in the database.
const transactions = mongoose.model("transactions", transactionSchema);

// Import the routes after models are registered
const achievementsRoutes = require("./routes/achievements");
app.use("/achievements", achievementsRoutes);

// Redirect / to /login, in the event that only the base URL is entered in the browser.
// This redirects the user to the home page if they are logged in.
app.get("/", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.redirect("/index");
});

// Here the server will recognise that the server is requested with the /login URL and will render the login file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/login", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("login");
});

app.get("/game", (request, result) => {
  if (!request.session.uid) {
    return result.redirect("/login");
  }
  result.render("game");
});

app.get("/add-expense", (req, res) => {
  res.render("partials/expense_log");
});


// PROFILE PAGE
// Fetch user info from mongoDB
// app.use('/scripts', express.static(__dirname + '/scripts'));
app.get("/profile", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    res.render("profile", { user });
  } catch (err) {
    console.error("Error fetching user:", err);
    res.status(500).send("Internal Server Error");
  }
});


// Post changes to mongoDB
app.post("/profile/update", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  const { username, password, weekly, monthly } = req.body;

  try {
    const update = {
      username,
      budget: {
        weekly: Number(weekly),
        monthly: Number(monthly),
      },
    };

    // Only hash password if it's provided and not blank
    if (password && password.trim() !== "") {
      const hashedPassword = await bcrypt.hash(password, 10);
      update.password = hashedPassword;
    }

    // Only update the selected field
    const updateOps = {};

    if (username) updateOps["username"] = username;
    if (password && password.trim() !== "") {
      const hashedPassword = await bcrypt.hash(password, 10);
      updateOps["password"] = hashedPassword;
    }
    if (weekly !== undefined) updateOps["budget.weekly"] = Number(weekly);
    if (monthly !== undefined) updateOps["budget.monthly"] = Number(monthly);

    // Update user with new profile values
    await users.findByIdAndUpdate(req.session.uid, { $set: updateOps });

    // Fetch updated user
    const user = await users.findById(req.session.uid);

    // Track "weekly" progress for "Start by setting your weekly budget" achievement
    if (weekly !== undefined && Number(weekly) > 0) {
      const weeklyAchievement = await achievements.findOne({
        _id: { $in: user.activeAchievements },
        type: "weekly",
        completed: false,
      });

      // If the 'weekly' achievement type exists for the user, and it hasn’t reached its target yet, then increase its progress by 1
      if (weeklyAchievement && weeklyAchievement.progress < weeklyAchievement.target) {
        weeklyAchievement.progress += 1;
        await weeklyAchievement.save();
      }
    }

    // Track "monthly" progress for "Set your monthly budget" achievement
    if (monthly !== undefined && Number(monthly) > 0) {
      const monthlyAchievement = await achievements.findOne({
        _id: { $in: user.activeAchievements },
        type: "monthly",
        completed: false,
      });
      // If the 'monthly' achievement type exists for the user, and it hasn’t reached its target yet, then increase its progress by 1
      if (monthlyAchievement && monthlyAchievement.progress < monthlyAchievement.target) {
        monthlyAchievement.progress += 1;
        await monthlyAchievement.save();
      }
    }

    res.status(200).json({ message: "Profile updated" });
  } catch (err) {
    console.error("Update error:", err.message);
    res.status(500).json({ error: "Database update failed" });
  }
});


// Here the server will recognise that the server is requested with the /home URL and will render the home file.
// If the user is not logged in, they will be redirected to the login page.
app.get("/home", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    const userTransactions = await transactions.find({
      _id: { $in: user.transactions },
    });
    const totalIncome = userTransactions
      .filter((t) => t.type === "income")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalExpenses = userTransactions
      .filter((t) => t.type === "expense")
      .reduce((sum, t) => sum + t.amount, 0);
    const balance = totalIncome - totalExpenses;
    res.render("home", {
      username: req.session.username,
      totalIncome,
      totalExpenses,
      balance,
      expenses: userTransactions,
      joke: req.session.joke
    });
  } catch (err) {
    console.error("Error loading home:", err.message);
    res.status(500).send("Internal Server Error");
  }
});


// Here the server will recognise that the server is requested with the /index URL and will render the index file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/index", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("index");
});


/**
 * Sign's up a new user.
 * If the user already exists, an error message is returned.
 * Uses bcrypt to hash the password before saving it to the database.
 * Add's five default achievements to the user, storing the id's in an array in user and adding the achievements to the database directly.
 * The new user is saved to the database and their uid is stored in the session.
 * The user is created from the mongoDB users model.
 */
app.post("/auth/register", async (req, res) => {
  try {
    const username = req.body.username;
    const password = req.body.password;
    const existingUser = await users.findOne({ username });
    if (existingUser) {
      return res.status(400).json({ error: "Username already exists" });
    }
    // Active Achievements
    const defaultActiveAchievements = [
      {
        type: "welcome",
        description: "Welcome to EconAmi!",
        progress: 1,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 5,
      },
      {
        type: "add_achievement",
        description: "Select an inactive achievement that you want to work on (remember, you can only have a max of 4 active achievements at a time!)",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
    ];

    // Inactive achievements
    const defaultInactiveAchievements = [
      {
        type: "weekly",
        description: "Start by setting your weekly budget from your profile page.",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "monthly",
        description: "Set your monthly budget from your profile page.",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "pet_ami",
        description: "Introduce yourself to Ami. Go ahead and pet Ami!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 5,
      },
      {
        type: "input_expense",
        description: "Input 3 expenses on the home page.",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "weekly_budget",
        description: "Hit your weekly budget goal!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 200,
      },
      {
        type: "monthly_budget",
        description: "Achieve your monthly budget goal!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 200,
      },
      {
        type: "ami_happiness",
        description: "Keep Ami's happiness above 85 for 3 days (go pet Ami!)",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "drink",
        description: "Bring your own drinks from home for 5 days. (Don't buy coffee outside!)",
        progress: 0,
        target: 5,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 50,
      },
      {
        type: "login",
        description: "Keep a daily login streak for 3 days!",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
    ];

    const activeAchievements = [];
    const inactiveAchievements = [];


    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    for (let i = 0; i < defaultActiveAchievements.length; i++) {
      defaultActiveAchievements[i].date.setMinutes(
        defaultActiveAchievements[i].date.getMinutes() +
        defaultActiveAchievements[i].date.getTimezoneOffset()
      );
      defaultActiveAchievements[i].previousDate.setMinutes(
        defaultActiveAchievements[i].previousDate.getMinutes() +
        defaultActiveAchievements[i].previousDate.getTimezoneOffset()
      );
    }

    for (const achievementData of defaultInactiveAchievements) {
      achievementData.date.setMinutes(
        achievementData.date.getMinutes() +
        achievementData.date.getTimezoneOffset()
      );
      achievementData.previousDate.setMinutes(
        achievementData.previousDate.getMinutes() +
        achievementData.previousDate.getTimezoneOffset()
      );

      const newAchievement = new achievements({
        ...achievementData,
        userId: req.session.uid
      });
      await newAchievement.save();
      inactiveAchievements.push(newAchievement._id);
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    for (const achievementData of defaultActiveAchievements) {
      achievementData.date.setMinutes(
        achievementData.date.getMinutes() +
        achievementData.date.getTimezoneOffset()
      );
      achievementData.previousDate.setMinutes(
        achievementData.previousDate.getMinutes() +
        achievementData.previousDate.getTimezoneOffset()
      );

      const newAchievement = new achievements({
        ...achievementData,
        userId: req.session.uid
      });
      await newAchievement.save();
      activeAchievements.push(newAchievement._id);
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new users({
      username,
      password: hashedPassword,
      categories: [
        "Income",
        "Rent",
        "Groceries",
        "Transportation",
        "Dining Out",
        "Entertainment",
        "Health",
        "Insurance",
        "Education",
        "Pets",
      ],
      balance: 0,
      transactions: [],
      activeAchievements,
      inactiveAchievements,
      budget: {
        weekly: 0,
        monthly: 0,
      },
      owned: [],
      pet: null,
      date: new Date(),
      coins: 0,
    });
    await newUser.save();
    req.session.uid = newUser._id;
    req.session.username = newUser.username;
    req.session.joke = null;
    res.redirect("/home");
  } catch (err) {
    console.log("Error during registration:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Log's in a user.
 * If the user does not exist, an error message is returned.
 * The password is compared to the hashed password in the database using bcrypt.
 * If the password is correct, the user's uid is stored in the session.
 * If the password is incorrect, an error message is returned.
 * The user is redirected to the home page upon successful login.
 */
app.post("/auth/login", async (request, result) => {
  try {
    const { username, password } = request.body;
    const user = await users.findOne({ username });
    if (!user) {
      return result.status(401).json({ error: "Invalid username or password" });
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return result.status(401).json({ error: "Invalid username or password" });
    }
    request.session.uid = user._id;
    request.session.username = user.username;
    request.session.joke = null;
    result.redirect("/home");
  } catch (err) {
    console.log("Error during login:", err.message);
    result.status(500).json({ error: err.message });
  }
});


/**
 * Log's out a user.
 * The session is destroyed and the user is redirected to the login page.
 * If there is an error during logout, an error message is returned.
 * The user is redirected to the login page upon successful logout.
 */
app.post("/auth/logout", (request, result) => {
  request.session.destroy((err) => {
    if (err) {
      return result
        .status(500)
        .json({ error: "Failed to log out:" + err.message });
    }
    result.redirect("/login");
  });
});


/**
 * Add's a new transaction.
 * The transaction is created from the mongoDB transactions model.
 * The transaction is saved to the database and the user's transactions array is updated automatically with the models ID.
 */
app.post("/transaction/add", (request, result) => {
  const name = request.body.name;
  const category = request.body.category;
  const date = new Date(request.body.date);
  /**
   * This is used to set the date to the correct timezone.
   * Without this, the date will be set to UTC time.
   * Generated by ChatGPT -4o
   *
   * @author https://chat.openai.com/
   */
  date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  const amount = request.body.amount;
  const comments = request.body.comments;
  const newTransaction = new transactions({
    name,
    category,
    date,
    amount,
    comments,
  });
  newTransaction
    .save()
    .then(() => {
      return users.findByIdAndUpdate(request.session.uid, {
        $push: { transactions: newTransaction._id },
      });
    })
    .then(() => {
      console.log(
        "Transaction added successfully to: ",
        request.session.uid,
        "! Details: ",
        newTransaction
      );
      result.redirect("/home");
    })
    .catch((err) => {
      console.log("Error adding transaction:", err.message);
      result.status(500).json({ error: "Internal server error" });
    });
});


/**
 * Fetches all transactions for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are identified and populated in a new temporary object to deliver while rendering the page.
 */
app.get("/transactions", async (req, res) => {
  try {
    if (!req.session.uid) {
      return res.redirect("/login");
    }

    const user = await users.findById(req.session.uid);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const { type, category } = req.query;
    const filter = { _id: { $in: user.transactions } };
    if (type) filter.type = type;
    if (category) filter.category = category;

    const transactionsList = await transactions.find(filter);
    console.log("Fetched Transactions:", transactionsList);
    res.render("transactions", {
      transactions: transactionsList,
      selectedType: type || "",
      selectedCategory: category || "",
    });
  } catch (err) {
    console.error("Error fetching /transactions route:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Fetches all transactions for the logged-in user. Dose not render a page.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are sent to the client as JSON.
 */
app.post("/transactions/fetch", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const transactionsList = await transactions.find({
      _id: { $in: user.transactions },
    });
    console.log("Fetched Transactions:", transactionsList);
    result.json({ transactions: transactionsList });
  } catch (err) {
    console.log("Error fetching transactions:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


app.get("/transactions/chart-data", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  try {
    const user = await users.findById(req.session.uid);
    const allTransactions = await transactions.find({
      _id: { $in: user.transactions },
      type: "expense", // optional: only show expenses in chart
    });

    // Aggregate total amounts by category
    const categoryTotals = {};
    allTransactions.forEach((t) => {
      categoryTotals[t.category] = (categoryTotals[t.category] || 0) + t.amount;
    });

    const labels = Object.keys(categoryTotals);
    const values = Object.values(categoryTotals);

    res.json({ labels, values });
  } catch (err) {
    console.error("Error fetching chart data:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Fetches all categories for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the categories are stored.
 * Since all categories are already listed in one place we just return the users categories array.
 */
app.post("/categories", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    if (!user) {
      return result.status(404).json({ error: "User not found" });
    }
    console.log("Fetched Categories:", user.categories);
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error fetching categories:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Add's a new category to the user's categories array.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/add", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories.push(category);
    await user.save();
    console.log(
      "Category ",
      category,
      " added successfully to user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error adding category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


/**
 * Delete's a category from the user's categories array.
 * Filters through and allows all categories that are not equal to the one being deleted.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/remove", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories = user.categories.filter((cat) => cat !== category);
    await user.save();
    console.log(
      "Category ",
      category,
      " deleted successfully from user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error deleting category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


app.get("/weather", async (req, res) => {
  const { lat, lon } = req.query;
  const apiKey = process.env.WEATHER_API_KEY;

  try {
    const response = await axios.get(
      `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}`
    );
    res.json(response.data);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch weather data" });
  }
});


/**
 * Fetches the user's budget's from the database.
 * Uses the user's ID stored in the session to find the user in the database where the budget's are stored.
 * The budget's are identified and populated in a new temporary object to deliver to the view.
 */
app.post("/budget", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    console.log("Fetched Budget:", user.budget);
    result.json({ budget: user.budget });
  } catch (err) {
    console.log("Error fetching budget:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});


// Delete a transaction
// Routed to home page
app.post("/delete-expense/:id", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    await transactions.findByIdAndDelete(req.params.id);
    await users.findByIdAndUpdate(req.session.uid, {
      $pull: { transactions: req.params.id },
    });

    console.log(`Transaction deleted successfully.`);
    res.redirect("/home");
  } catch (error) {
    console.error("Error deleting transaction:", error.message);
    res.status(500).send("Error deleting transaction");
  }
});


// Handle form submission and save to MongoDB
app.post("/add-expense", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).send("Unauthorized: user not logged in");
  }
  const user = await users.findById(req.session.uid);
  const { type, name, amount, category, date } = req.body;
  try {
    const newTransaction = new transactions({
      type,
      name,
      amount,
      category,
      date: new Date(date),
    });
    await newTransaction.save();
    try {
      await user.transactions.push(newTransaction._id);
      await user.save();
    } catch (err) {
      console.error("Error saving transaction to user:", err.message);
      return res.status(500).send("Error saving transaction to user");
    }
    res.redirect("/home");
  } catch (err) {
    console.error("Error saving transaction: ", err.message);
    res.status(500).send("Error saving transaction");
  }
});

/**
 * Requests a joke from the OpenAI API using the axios library.
 * The request is plain text as if your talking to the chatbot on it's website.
 * The following prompt was used to acheive our project's goal.
 * Roles user and assistant are their way of identifing who is talking.
 * The bearer is the person who owns the api giving you their key.
 * The model is the version of the gpt we are using. (currently the cheapest to use for the best randomness)
 * This script was made by modifying the origional code from OpenAI... as such.
 * 
 * @author OpenAI
 */
app.post("/joke", async (req, res) => {
  try {
    const aiResponse = await axios.post(
      "https://api.openai.com/v1/chat/completions",
      {
        model: "gpt-4o",
        temperature: 0.9,
        presence_penalty: 0.6,
        frequency_penalty: 0.4,
        messages: [
          {
            role: "user",
            content:
              "Make a unique, short, school-friendly joke in 1 - 2 sentences. Be creative so you avoid repeating earlier jokes.",
          },
        ],
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.chatGPT}`,
        },
      }
    );
    req.session.joke = aiResponse.data.choices[0].message.content;
    console.log("Fetched Joke:", req.session.joke);
    res.redirect("/home");
  } catch (error) {
    console.error("Error fetching joke:", error.message);
    res.status(500).send("Error fetching joke");
  }
});

// Start's the server and listens on the specified port.
// The port is set to 3000 by default.
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
