const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require("bcrypt");
const session = require('express-session');
const favicon = require('serve-favicon');
const path = require('path');

/**
 * Require dotenv to load environment variables from a .env file for security.
 * This will allow secret keys to be stored in a .env file instead of hardcoded in the code.
 * The file is not included in the repository and is added to the .gitignore file.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
require('dotenv').config();
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

const app = express();

/**
 * Set the port to the environment variable or default to 3000.
 * This allows the server to run on different ports depending on the environment.
 * This is useful for deployment and testing.
 * Generated by ChatGPT -4o
 * 
 * @author https://chat.openai.com/
 */
const PORT = process.env.PORT || 3000; // Set the port to the environment variable or default to 3000
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Set EJS as the view engine
app.set('view engine', 'ejs');
app.set('views', __dirname + '/views'); // Set the views directory

/**
 * Middleware to parse JSON and handle sessions, and URL-encoded data parsing, and serve static files.
 * This middleware is used to parse incoming JSON requests and manage user sessions. It also helps serve static files like photo's.
 * This is important for handling form submissions and user authentication, as well as helping the server to serve static files like CSS, JS, and images.
 * 
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
// Middleware to parse JSON
app.use(express.json());

// Middleware to serve static files (CSS, JS, images)
app.use(express.static('public'));

// Middleware to use favicon
// app.use(express.favicon(__dirname + '/public/images/favicon.png'));
app.use(favicon(path.join(__dirname, 'public', 'images', 'favicon.png')));

// Middleware to parse URL-encoded form data
app.use(express.urlencoded({ extended: true }));

// Middleware for sessions
app.use(session({
    secret: process.env.SECRETKEY,
    resave: false,
    saveUninitialized: true,
    cookie: { maxAge: 86400000 }
}));
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


// Database connection
mongoose.connect(process.env.MONGO_STRING, {

    /** 
     * Setting's for database connection
     * With these settings, we can avoid deprecation warnings and ensure a more stable connection.
     * Generated by ChatGPT -4o
     * 
     * @author https://chat.openai.com/
     */
    useNewUrlParser: true,
    useUnifiedTopology: true,
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

}).then(() => {
    console.log('Connected to database successfully!');
}).catch((err) => {
    console.log('Error connecting to database:', err.message);
});

/** This is the schema for users, it acts as a template for models to use when creating new documents in the database.
 *  Transaction ID's are included in the user schema.
 *  Pets are included in the user schema.
 */
const userSchema = new mongoose.Schema({
    username: String,
    password: String,
    categories: Array,
    balance: Number,
    transactions: Array,
    acheivements: Array,
    owned: Array,
    pet: String,
    date: Date,
    budget: {
        daily: Number,
        weekly: Number,
        monthly: Number
    }
});

/**
 * This is the schema for transactions, it acts as a template for models to use when creating new documents in the database.
 * Transactions are tied to users in there user schema by thier model ID.
 * The server automatically adds the transaction ID to the user schema when a new transaction is created.
 */
const transactionSchema = new mongoose.Schema({
    name: String,
    category: String,
    date: Date,
    amount: Number,
    comments: String
});

/**
 * This is the schema for acheivements, it acts as a template for models to use when creating new documents in the database.
 * Acheivements are tied to users in there user schema by thier model ID.
 * The server automatically adds the acheivement ID to the user schema when a new acheivement is created.
 */
const acheivementSchema = new mongoose.Schema({
    type: String,
    description: String,
    progress: Number,
    target: Number,
    date: Date,
    previousDate: Date,
    completed: Boolean
});

// Here we create a model for the acheivement schema, this will be used to make our collection in the database.
const acheivements = mongoose.model('acheivements', acheivementSchema);

// Here we create a model for the user schema, this will be used to make our collection in the database.
const users = mongoose.model('users', userSchema);

// Here we create a model for the transaction schema, this will be used to make our collection in the database.
const transactions = mongoose.model('transactions', transactionSchema);

// Redirect / to /login, in the event that only the base URL is entered in the browser.
// This redirects the user to the home page if they are logged in.
app.get('/', (request, result) => {
    if (request.session.uid) {
        return result.redirect('/home');
    }
    result.redirect('/index');
});

// Here the server will recognise that the server is requested with the /login URL and will render the login file.
// If the user is already logged in, they will be redirected to the home page.
app.get('/login', (request, result) => {
    if (request.session.uid) {
        return result.redirect('/home');
    }
    result.render('login');
});

app.get('/game', (request, result) => {
    if (!request.session.uid) {
        return result.redirect('/login');
    }
    result.render('game');
});

// ACHIEVEMENTS PAGE
/**
 * Here the server will recognise that the server is requested with the /achievements URL and will render the achievements file.
 * The server will also serve the user's acheivements to the page in json format.
 * If the user is not logged in, they will be redirected to the login page.
 */
app.get('/achievements', (request, result) => {
    if (!request.session.uid) {
        return result.redirect('/login');
    }
    const user = users.findById(request.session.uid);
    const userAchievements = acheivements.find({ _id: { $in: user.acheivements } });
    result.render('achievements', { user: user, achievements: userAchievements });
});

// PROFILE PAGE
// Fetch user info from mongoDB
// app.use('/scripts', express.static(__dirname + '/scripts'));
app.get('/profile', async (req, res) => {
    if (!req.session.uid) {
        return res.redirect('/login');
    }

    try {
        const user = await users.findById(req.session.uid).lean();
        if (!user) return res.status(404).send('User not found');
        res.render('profile', { user });
    } catch (err) {
        console.error('Error fetching user:', err);
        res.status(500).send('Internal Server Error');
    }
});

// Post changes to mongoDB
app.post('/profile/update', async (req, res) => {
    if (!req.session.uid) return res.status(401).json({ error: 'Unauthorized' });

    const { username, password, daily, weekly, monthly } = req.body;

    try {
        const update = {
            username,
            budget: {
                daily: Number(daily),
                weekly: Number(weekly),
                monthly: Number(monthly)
            }
        };

        // Only hash password if it's provided and not blank
        if (password && password.trim() !== '') {
            const hashedPassword = await bcrypt.hash(password, 10);
            update.password = hashedPassword;
        }

        await users.findByIdAndUpdate(req.session.uid, update);
        res.status(200).json({ message: 'Profile updated' });
    } catch (err) {
        console.error('Update error:', err.message);
        res.status(500).json({ error: 'Database update failed' });
    }
});



// Here the server will recognise that the server is requested with the /home URL and will render the home file.
// If the user is not logged in, they will be redirected to the login page.
app.get('/home', (request, result) => {
    if (!request.session.uid) {
        return result.redirect('/login');
    }
    result.render('home', { username: request.session.username });
});

// Here the server will recognise that the server is requested with the /index URL and will render the index file.
// If the user is already logged in, they will be redirected to the home page.
app.get('/index', (request, result) => {
    if (request.session.uid) {
        return result.redirect('/home');
    }
    result.render('index');
});

/**
 * Sign's up a new user.
 * If the user already exists, an error message is returned.
 * Uses bcrypt to hash the password before saving it to the database.
 * Add's five default acheivements to the user, storing the id's in an array in user and adding the acheivements to the database directly.
 * The new user is saved to the database and their uid is stored in the session.
 * The user is created from the mongoDB users model.
 */
app.post('/auth/register', async (request, result) => {
    try {
        const username = request.body.username;
        const password = request.body.password;
        const existingUser = await users.findOne({ username });
        if (existingUser) {
            return result.status(400).json({ error: 'Username already exists' });
        }
        const defaultAcheivements = [
            { type: 'Daily', description: 'Dont go over the days budget!', progress: 0, target: 1, date: new Date(), previousDate: new Date(), completed: false },
            { type: 'Weekly', description: 'Dont go over the weeks budget!', progress: 0, target: 1, date: new Date(), previousDate: new Date(), completed: false },
            { type: 'Monthly', description: 'Dont go over the months budget!', progress: 0, target: 1, date: new Date(), previousDate: new Date(), completed: false },
            { type: 'Drink', description: 'Dont buy any drinks for five days! (Dont add water to your transactions!)', progress: 0, target: 5, date: new Date(), previousDate: new Date(), completed: false },
            { type: 'Login', description: 'Your daily login reward!', progress: 0, target: 1, date: new Date(), previousDate: new Date(), completed: false }
        ];
        const acheiveArray = [];
        for (let i = 0; i < defaultAcheivements.length; i++) {
            const newAcheivement = new acheivements(defaultAcheivements[i]);
            await newAcheivement.save();
            acheiveArray.push(newAcheivement._id);
        }
        const hashedPassword = await bcrypt.hash(password, 10);
        const newUser = new users({
            username,
            password: hashedPassword,
            categories: [
                "Income",
                "Rent",
                "Groceries",
                "Transportation",
                "Dining Out",
                "Entertainment",
                "Health",
                "Insurance",
                "Education",
                "Pets"
            ],
            balance: 0,
            transactions: [],
            acheivements: acheiveArray,
            owned: [],
            pet: null,
            date: new Date()
        });
        await newUser.save();
        request.session.uid = newUser._id;
        request.session.username = newUser.username;
        result.redirect('/home');
    } catch (err) {
        console.log('Error during registration:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Log's in a user.
 * If the user does not exist, an error message is returned.
 * The password is compared to the hashed password in the database using bcrypt.
 * If the password is correct, the user's uid is stored in the session.
 * If the password is incorrect, an error message is returned.
 * The user is redirected to the home page upon successful login.
 */
app.post('/auth/login', async (request, result) => {
    try {
        const { username, password } = request.body;
        const user = await users.findOne({ username });
        if (!user) {
            return result.status(401).json({ error: 'Invalid username or password' });
        }
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return result.status(401).json({ error: 'Invalid username or password' });
        }
        request.session.uid = user._id;
        request.session.username = user.username;
        result.redirect('/home');
    } catch (err) {
        console.log('Error during login:', err.message);
        result.status(500).json({ error: err.message });
    }
});

/*
 * Log's out a user.
 * The session is destroyed and the user is redirected to the login page.
 * If there is an error during logout, an error message is returned.
 * The user is redirected to the login page upon successful logout.
 */
app.post('/auth/logout', (request, result) => {
    request.session.destroy(err => {
        if (err) {
            return result.status(500).json({ error: 'Failed to log out:' + err.message });
        }
        result.redirect('/login');
    });
});

/**
 * Add's a new transaction.
 * The transaction is created from the mongoDB transactions model.
 * The transaction is saved to the database and the user's transactions array is updated automatically with the models ID.
 */
app.post('/transaction/add', (request, result) => {
    const name = request.body.name;
    const category = request.body.category;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const amount = request.body.amount;
    const comments = request.body.comments;
    const newTransaction = new transactions({
        name,
        category,
        date,
        amount,
        comments
    });
    newTransaction.save()
        .then(() => {
            return users.findByIdAndUpdate(request.session.uid, { $push: { transactions: newTransaction._id } });
        })
        .then(() => {
            console.log('Transaction added successfully to: ', request.session.uid, '! Details: ', newTransaction);
            result.redirect('/home');
        })
        .catch(err => {
            console.log('Error adding transaction:', err.message);
            result.status(500).json({ error: 'Internal server error' });
        });
});

/**
 * Fetches all transactions for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are identified and populated in a new temporary object to deliver while rendering the page.
 */
app.get('/transactions', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        if (!user) {
            return result.status(404).json({ error: 'User not found' });
        }
        const transactionsList = await transactions.find({ _id: { $in: user.transactions } });
        console.log('Fetched Transactions:', transactionsList);
        result.render('transactions', { transactions: transactionsList });
    } catch (err) {
        console.log('Error fetching transactions:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Fetches all transactions for the logged-in user. Dose not render a page.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are sent to the client as JSON.
 */
app.post('/transactions/fetch', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        const transactionsList = await transactions.find({ _id: { $in: user.transactions } });
        console.log('Fetched Transactions:', transactionsList);
        result.json({ transactions: transactionsList });
    } catch (err) {
        console.log('Error fetching transactions:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Fetches all categories for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the categories are stored.
 * Since all categories are already listed in one place we just return the users categories array.
 */
app.post('/categories', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        if (!user) {
            return result.status(404).json({ error: 'User not found' });
        }
        console.log('Fetched Categories:', user.categories);
        result.json({ categories: user.categories });
    } catch (err) {
        console.log('Error fetching categories:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Add's a new category to the user's categories array.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post('/categories/add', async (request, result) => {
    try {
        const category = request.body.category;
        if (!request.session.uid) {
            return result.status(404).json({ error: 'User not found' });
        }
        const user = await users.findById(request.session.uid);
        user.categories.push(category);
        await user.save();
        console.log('Category ', category, ' added successfully to user:', request.session.uid);
        result.json({ categories: user.categories });
    } catch (err) {
        console.log('Error adding category:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Delete's a category from the user's categories array.
 * Filters through and allows all categories that are not equal to the one being deleted.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post('/categories/remove', async (request, result) => {
    try {
        const category = request.body.category;
        if (!request.session.uid) {
            return result.status(404).json({ error: 'User not found' });
        }
        const user = await users.findById(request.session.uid);
        user.categories = user.categories.filter(cat => cat !== category);
        await user.save();
        console.log('Category ', category, ' deleted successfully from user:', request.session.uid);
        result.json({ categories: user.categories });
    } catch (err) {
        console.log('Error deleting category:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Fetches the user's budget's from the database.
 * Uses the user's ID stored in the session to find the user in the database where the budget's are stored.
 * The budget's are identified and populated in a new temporary object to deliver to the view.
 */
app.post('/budget', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        console.log('Fetched Budget:', user.budget);
        result.json({ budget: user.budget });
    } catch (err) {
        console.log('Error fetching budget:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Fetches the users achievements from the database, along with their user information.
 * Uses the user's ID stored in the session to find the user in the database where the achievements are stored.
 * The achievements are identified and delivered to the view.
 * The user information is also delivered to the view.
 */
app.post('/achievements', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        const userAchievements = await acheivements.find({ _id: { $in: user.acheivements } });
        console.log('Fetched Achievements:', userAchievements);
        result.json({ achievements: userAchievements, user: user });
    } catch (err) {
        console.log('Error fetching achievements:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

/**
 * Updates the acheivement that is passed by the script in the view.
 * The acheivement is identified by its ID and the new data is passed to the database.
 * The acheivement is updated in the database, with the new progress, completed and date and previousDate values.
 */
app.post('/achievements/update', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const acheivementId = request.body.acheivementId;
        const progress = request.body.progress;
        const completed = request.body.completed;
        const date = new Date(request.body.date);
        const previousDate = new Date(request.body.previousDate);
        await acheivements.findByIdAndUpdate(acheivementId, { progress, completed, date, previousDate });
        console.log('Updated Achievement:', acheivementId);
        result.json({ message: 'Achievement updated successfully' });
    } catch (err) {
        console.log('Error updating achievement:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

// Start's the server and listens on the specified port.
// The port is set to 3000 by default.
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});