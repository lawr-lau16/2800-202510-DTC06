const express = require("express");
const mongoose = require("mongoose");
const bcrypt = require("bcrypt");
const session = require('express-session');
const favicon = require('serve-favicon');
const path = require('path');
const axios = require('axios');
const { type } = require("os");

/**
 * Require dotenv to load environment variables from a .env file for security.
 * This will allow secret keys to be stored in a .env file instead of hardcoded in the code.
 * The file is not included in the repository and is added to the .gitignore file.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
require("dotenv").config();
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

const app = express();

/**
 * Set the port to the environment variable or default to 3000.
 * This allows the server to run on different ports depending on the environment.
 * This is useful for deployment and testing.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
const PORT = process.env.PORT || 3000; // Set the port to the environment variable or default to 3000
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Set EJS as the view engine
app.set("view engine", "ejs");
app.set("views", __dirname + "/views"); // Set the views directory

/**
 * Middleware to parse JSON and handle sessions, and URL-encoded data parsing, and serve static files.
 * This middleware is used to parse incoming JSON requests and manage user sessions. It also helps serve static files like photo's.
 * This is important for handling form submissions and user authentication, as well as helping the server to serve static files like CSS, JS, and images.
 *
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
// Middleware to parse JSON
app.use(express.json());

// Middleware to serve static files (CSS, JS, images)
app.use(express.static("public"));

// Middleware to use favicon
// app.use(express.favicon(__dirname + '/public/images/favicon.png'));
app.use(favicon(path.join(__dirname, "public", "images", "favicon.png")));

// Middleware to parse URL-encoded form data
app.use(express.urlencoded({ extended: true }));

// Middleware for sessions
app.use(
  session({
    secret: process.env.SECRETKEY,
    resave: false,
    saveUninitialized: true,
    cookie: { maxAge: 86400000 },
  })
);
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Database connection
mongoose
  .connect(process.env.MONGO_STRING, {
    /**
     * Setting's for database connection
     * With these settings, we can avoid deprecation warnings and ensure a more stable connection.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    useNewUrlParser: true,
    useUnifiedTopology: true,
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  })
  .then(() => {
    console.log("Connected to database successfully!");
  })
  .catch((err) => {
    console.log("Error connecting to database:", err.message);
  });

/** This is the schema for users, it acts as a template for models to use when creating new documents in the database.
 *  Transaction ID's are included in the user schema.
 *  Pets are included in the user schema.
 */
const userSchema = new mongoose.Schema({
  username: String,
  password: String,
  categories: Array,
  balance: Number,
  transactions: Array,
  achievements: Array,
  inventory: Array,
  pet: {
    base: String,
    item: String,
    happiness: Number
  },
  date: Date,
  budget: {
    weekly: Number,
    monthly: Number
  },
  coins: Number
});

/**
 * This is the schema for transactions, it acts as a template for models to use when creating new documents in the database.
 * Transactions are tied to users in there user schema by thier model ID.
 * The server automatically adds the transaction ID to the user schema when a new transaction is created.
 */
const transactionSchema = new mongoose.Schema({
  name: String,
  category: String,
  date: Date,
  amount: Number,
  comments: String,
  type: String
});

/**
 * This is the schema for achievements, it acts as a template for models to use when creating new documents in the database.
 * Achievements are tied to users in there user schema by thier model ID.
 * The server automatically adds the achievement ID to the user schema when a new achievement is created.
 */
const achievementSchema = new mongoose.Schema({
  type: String,
  description: String,
  progress: Number,
  target: Number,
  date: Date,
  previousDate: Date,
  completed: Boolean,
  reward: Number
});

// Here we create a model for the achievement schema, this will be used to make our collection in the database.
const achievements = mongoose.model("achievements", achievementSchema);

// Here we create a model for the user schema, this will be used to make our collection in the database.
const users = mongoose.model("users", userSchema);

// Here we create a model for the transaction schema, this will be used to make our collection in the database.
const transactions = mongoose.model("transactions", transactionSchema);

// Redirect / to /login, in the event that only the base URL is entered in the browser.
// This redirects the user to the home page if they are logged in.
app.get("/", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.redirect("/index");
});

// Here the server will recognise that the server is requested with the /login URL and will render the login file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/login", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("login");
});

app.get("/game", (request, result) => {
  if (!request.session.uid) {
    return result.redirect("/login");
  }
  result.render("game");
});

app.get("/add-expense", (req, res) => {
    res.render("partials/expense_log");
});

// ACHIEVEMENTS PAGE
/**
 * Here the server will recognise that the server is requested with the /achievements URL and will render the achievements file.
 * The server will also serve the user's achievements to the page in json format.
 * If the user is not logged in, they will be redirected to the login page.
 */
app.get('/achievements', async (req, res) => {
    if (!req.session.uid) {
        return res.redirect('/login');
    }

    try {
        const user = await users.findById(req.session.uid);
        const userAchievements = await achievements.find({ _id: { $in: user.achievements } });
        res.render('achievements', { user, achievements: userAchievements });
    } catch (err) {
        console.error('Error loading achievements:', err);
        res.status(500).send('Server error');
    }
});

// Route to get achievement data
app.get('/achievements-data', async (req, res) => {
    if (!req.session.uid) {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const user = await users.findById(req.session.uid);
    const userAchievements = await achievements.find({ _id: { $in: user.achievements } });

    res.json({ achievements: userAchievements });
});

// PROFILE PAGE
// Fetch user info from mongoDB
// app.use('/scripts', express.static(__dirname + '/scripts'));
app.get("/profile", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    res.render("profile", { user });
  } catch (err) {
    console.error("Error fetching user:", err);
    res.status(500).send("Internal Server Error");
  }
});

// Post changes to mongoDB
app.post("/profile/update", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  const { username, password, weekly, monthly } = req.body;

  try {
    const update = {
      username,
      budget: {
        weekly: Number(weekly),
        monthly: Number(monthly)
      }
    };

    // Only hash password if it's provided and not blank
    if (password && password.trim() !== "") {
      const hashedPassword = await bcrypt.hash(password, 10);
      update.password = hashedPassword;
    }

    // Only update the selected field
    const updateOps = {};

    if (username) updateOps['username'] = username;
    if (password && password.trim() !== '') {
      const hashedPassword = await bcrypt.hash(password, 10);
      updateOps['password'] = hashedPassword;
    }
    if (weekly !== undefined) updateOps['budget.weekly'] = Number(weekly);
    if (monthly !== undefined) updateOps['budget.monthly'] = Number(monthly);
    
    await users.findByIdAndUpdate(req.session.uid, { $set: updateOps });
    res.status(200).json({ message: "Profile updated" });
  } catch (err) {
    console.error("Update error:", err.message);
    res.status(500).json({ error: "Database update failed" });
  }
});

// Here the server will recognise that the server is requested with the /home URL and will render the home file.
// If the user is not logged in, they will be redirected to the login page.
app.get("/home", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
      const user = await users.findById(req.session.uid);
      const userTransactions = await transactions.find({ _id: { $in: user.transactions } });
    const totalIncome = userTransactions
      .filter((t) => t.type === "income")
      .reduce((sum, t) => sum + t.amount, 0);
      const totalExpenses = userTransactions
      .filter((t) => t.type === "expense")
      .reduce((sum, t) => sum + t.amount, 0);
    const balance = totalIncome - totalExpenses;
    res.render("home", {
      username: req.session.username,
      totalIncome,
      totalExpenses,
      balance,
      expenses: userTransactions
    });
  } catch (err) {
    console.error("Error loading home:", err.message);
    res.status(500).send("Internal Server Error");
  }
});

// Here the server will recognise that the server is requested with the /index URL and will render the index file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/index", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("index");
});

/**
 * Sign's up a new user.
 * If the user already exists, an error message is returned.
 * Uses bcrypt to hash the password before saving it to the database.
 * Add's five default achievements to the user, storing the id's in an array in user and adding the achievements to the database directly.
 * The new user is saved to the database and their uid is stored in the session.
 * The user is created from the mongoDB users model.
 */
app.post("/auth/register", async (request, result) => {
  try {
    const username = request.body.username;
    const password = request.body.password;
    const existingUser = await users.findOne({ username });
    if (existingUser) {
      return result.status(400).json({ error: "Username already exists" });
    }
    const defaultAchievements = [
      {
        type: "Daily",
        description: "Dont go over the days budget!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 20
      },
      {
        type: "Weekly",
        description: "Dont go over the weeks budget!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 60
      },
      {
        type: "Monthly",
        description: "Dont go over the months budget!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 200
      },
      {
        type: "Drink",
        description:
          "Dont buy any drinks for five days! (Dont add water to your transactions!)",
        progress: 0,
        target: 5,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 50
      },
      {
        type: "Login",
        description: "Your daily login reward!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10
      }
    ];
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    for (let i = 0; i < defaultAchievements.length; i++) {
      defaultAchievements[i].date.setMinutes(
        defaultAchievements[i].date.getMinutes() +
        defaultAchievements[i].date.getTimezoneOffset()
      );
      defaultAchievements[i].previousDate.setMinutes(
        defaultAchievements[i].previousDate.getMinutes() +
        defaultAchievements[i].previousDate.getTimezoneOffset()
      );
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const achieveArray = [];
    for (let i = 0; i < defaultAchievements.length; i++) {
      const newAchievement = new achievements(defaultAchievements[i]);
      await newAchievement.save();
      achieveArray.push(newAchievement._id);
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new users({
      username,
      password: hashedPassword,
      categories: [
        "Income",
        "Rent",
        "Groceries",
        "Transportation",
        "Dining Out",
        "Entertainment",
        "Health",
        "Insurance",
        "Education",
        "Pets"
      ],
      balance: 0,
      transactions: [],
      achievements: achieveArray,
      budget: {
        weekly: 0,
        monthly: 0
      },
      owned: [],
      pet: null,
      date: new Date()
    });
    await newUser.save();
    request.session.uid = newUser._id;
    request.session.username = newUser.username;
    result.redirect("/home");
  } catch (err) {
    console.log("Error during registration:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Log's in a user.
 * If the user does not exist, an error message is returned.
 * The password is compared to the hashed password in the database using bcrypt.
 * If the password is correct, the user's uid is stored in the session.
 * If the password is incorrect, an error message is returned.
 * The user is redirected to the home page upon successful login.
 */
app.post("/auth/login", async (request, result) => {
  try {
    const { username, password } = request.body;
    const user = await users.findOne({ username });
    if (!user) {
      return result.status(401).json({ error: "Invalid username or password" });
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return result.status(401).json({ error: "Invalid username or password" });
    }
    request.session.uid = user._id;
    request.session.username = user.username;
    result.redirect("/home");
  } catch (err) {
    console.log("Error during login:", err.message);
    result.status(500).json({ error: err.message });
  }
});

/**
 * Log's out a user.
 * The session is destroyed and the user is redirected to the login page.
 * If there is an error during logout, an error message is returned.
 * The user is redirected to the login page upon successful logout.
 */
app.post("/auth/logout", (request, result) => {
  request.session.destroy((err) => {
    if (err) {
      return result
        .status(500)
        .json({ error: "Failed to log out:" + err.message });
    }
    result.redirect("/login");
  });
});

/**
 * Add's a new transaction.
 * The transaction is created from the mongoDB transactions model.
 * The transaction is saved to the database and the user's transactions array is updated automatically with the models ID.
 */
app.post("/transaction/add", (request, result) => {
  const name = request.body.name;
  const category = request.body.category;
  const date = new Date(request.body.date);
  /**
   * This is used to set the date to the correct timezone.
   * Without this, the date will be set to UTC time.
   * Generated by ChatGPT -4o
   *
   * @author https://chat.openai.com/
   */
  date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  const amount = request.body.amount;
  const comments = request.body.comments;
  const newTransaction = new transactions({
    name,
    category,
    date,
    amount,
    comments
  });
  newTransaction
    .save()
    .then(() => {
      return users.findByIdAndUpdate(request.session.uid, {
        $push: { transactions: newTransaction._id },
      });
    })
    .then(() => {
      console.log(
        "Transaction added successfully to: ",
        request.session.uid,
        "! Details: ",
        newTransaction
      );
      result.redirect("/home");
    })
    .catch((err) => {
      console.log("Error adding transaction:", err.message);
      result.status(500).json({ error: "Internal server error" });
    });
});

/**
 * Fetches all transactions for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are identified and populated in a new temporary object to deliver while rendering the page.
 */
app.get("/transactions", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    if (!user) {
      return result.status(404).json({ error: "User not found" });
    }
    const transactionsList = await transactions.find({
      _id: { $in: user.transactions },
    });
    console.log("Fetched Transactions:", transactionsList);
    result.render("transactions", { transactions: transactionsList });
  } catch (err) {
    console.log("Error fetching transactions:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Fetches all transactions for the logged-in user. Dose not render a page.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are sent to the client as JSON.
 */
app.post("/transactions/fetch", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const transactionsList = await transactions.find({
      _id: { $in: user.transactions },
    });
    console.log("Fetched Transactions:", transactionsList);
    result.json({ transactions: transactionsList });
  } catch (err) {
    console.log("Error fetching transactions:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Fetches all categories for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the categories are stored.
 * Since all categories are already listed in one place we just return the users categories array.
 */
app.post("/categories", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    if (!user) {
      return result.status(404).json({ error: "User not found" });
    }
    console.log("Fetched Categories:", user.categories);
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error fetching categories:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Add's a new category to the user's categories array.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/add", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories.push(category);
    await user.save();
    console.log(
      "Category ",
      category,
      " added successfully to user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error adding category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Delete's a category from the user's categories array.
 * Filters through and allows all categories that are not equal to the one being deleted.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/remove", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories = user.categories.filter((cat) => cat !== category);
    await user.save();
    console.log(
      "Category ",
      category,
      " deleted successfully from user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error deleting category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Fetches the users achievements from the database, along with their user information.
 * Uses the user's ID stored in the session to find the user in the database where the achievements are stored.
 * The achievements are identified and delivered to the view.
 * The user information is also delivered to the view.
 */
app.post("/achievements", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const userAchievements = await achievements.find({
      _id: { $in: user.achievements },
    });
    console.log("Fetched Achievements:", userAchievements);
    result.json({ achievements: userAchievements, user: user });
  } catch (err) {
    console.log("Error fetching achievements:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Updates the achievement that is passed by the script in the view.
 * The achievement is identified by its ID and the new data is passed to the database.
 * The achievement is updated in the database, with the new progress, completed and date and previousDate values.
 */
app.post("/achievements/update", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const achievementId = request.body.achievementId;
    const progress = request.body.progress;
    const completed = request.body.completed;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    await achievements.findByIdAndUpdate(achievementId, {
      progress,
      completed,
      date,
      previousDate
    });
    console.log("Updated Achievement:", achievementId);
    result.json({ message: "Achievement updated successfully" });
  } catch (err) {
    console.log("Error updating achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Replace's an achievement with a new one.
 * The new achievement is created from the mongoDB achievements model, and populated with the new data passed to the server.
 * The new achievement is saved to the database and the user's achievements array.
 * The old achievement is deleted, and its id removed from user's achievements array, and the reward is returned to the view.
 */
app.post("/achievements/replace", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const type = request.body.type;
    const description = request.body.description;
    const progress = request.body.progress;
    const target = request.body.target;
    const date = new Date(request.body.date);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const previousDate = new Date(request.body.previousDate);
    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    previousDate.setMinutes(
      previousDate.getMinutes() + previousDate.getTimezoneOffset()
    );
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    const completed = request.body.completed;
    const reward = request.body.reward;
    const oldID = request.body.oldID;
    const newAchievement = new achievements({
      type,
      description,
      progress,
      target,
      date,
      previousDate,
      completed,
      reward,
    });
    await newAchievement.save();
    await users.findByIdAndUpdate(request.session.uid, {
      $push: { achievements: newAchievement._id },
    });
    const oldReward = await achievements.findById(oldID);
    await achievements.findByIdAndDelete(oldID);
    await users.findByIdAndUpdate(request.session.uid, {
      $pull: { achievements: oldID },
    });
    console.log("Replaced and achievement with:", newAchievement);
    result.json({ reward: oldReward.reward });
  } catch (err) {
    console.log("Error replacing achievement:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

app.get("/weather", async (req, res) => {
  const { lat, lon } = req.query;
  const apiKey = process.env.WEATHER_API_KEY

  try {
    const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}`);
    res.json(response.data);
  }
  catch (error) {
    res.status(500).json({ error: "Failed to fetch weather data" })
  }
})

/**
 * Fetches the user's budget's from the database.
 * Uses the user's ID stored in the session to find the user in the database where the budget's are stored.
 * The budget's are identified and populated in a new temporary object to deliver to the view.
 */
app.post('/budget', async (request, result) => {
    try {
        if (!request.session.uid) {
            return result.redirect('/login');
        }
        const user = await users.findById(request.session.uid);
        console.log('Fetched Budget:', user.budget);
        result.json({ budget: user.budget });
    } catch (err) {
        console.log('Error fetching budget:', err.message);
        result.status(500).json({ error: 'Internal server error' });
    }
});

// Delete a transaction
// Routed to home page
app.post("/delete-expense/:id", async (req, res) => {
    if (!req.session.uid) {
        return res.redirect("/login");
    }
    try {
        await transactions.findByIdAndDelete(req.params.id);
        await users.findByIdAndUpdate(req.session.uid, {
            $pull: { transactions: req.params.id },
        });

        console.log(`Transaction deleted successfully.`);
        res.redirect("/home");
    } catch (error) {
        console.error("Error deleting transaction:", error.message);
        res.status(500).send("Error deleting transaction");
    }
});

// Handle form submission and save to MongoDB
app.post("/add-expense", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).send("Unauthorized: user not logged in");
  }
  const user = await users.findById(req.session.uid);
  const { type, name, amount, category, date } = req.body;
  try {
    const newTransaction = new transactions({
      type,
      name,
      amount,
      category,
      date: new Date(date),
    });
    await newTransaction.save();
    try {
        await user.transactions.push(newTransaction._id);
        await user.save();
    } catch (err) {
        console.error("Error saving transaction to user:", err.message);
        return res.status(500).send("Error saving transaction to user");
    }
    res.redirect("/home");
  } catch (err) {
    console.error("Error saving transaction: ", err.message);
    res.status(500).send("Error saving transaction");
  }
});

// Start's the server and listens on the specified port.
// The port is set to 3000 by default.
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
