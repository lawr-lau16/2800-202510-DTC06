const express = require("express");
const mongoose = require("mongoose");
const bcrypt = require("bcrypt");
const session = require("express-session");
const favicon = require("serve-favicon");
const path = require("path");
const axios = require("axios");
const { type } = require("os");
const OpenAI = require("openai");

/**
 * Require dotenv to load environment variables from a .env file for security.
 * This will allow secret keys to be stored in a .env file instead of hardcoded in the code.
 * The file is not included in the repository and is added to the .gitignore file.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
require("dotenv").config();
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

const app = express();

/**
 * Set the port to the environment variable or default to 3000.
 * This allows the server to run on different ports depending on the environment.
 * This is useful for deployment and testing.
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
const PORT = process.env.PORT || 3000; // Set the port to the environment variable or default to 3000
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Set EJS as the view engine
app.set("view engine", "ejs");
app.set("views", __dirname + "/views"); // Set the views directory

/**
 * Middleware to parse JSON and handle sessions, and URL-encoded data parsing, and serve static files.
 * This middleware is used to parse incoming JSON requests and manage user sessions. It also helps serve static files like photo's.
 * This is important for handling form submissions and user authentication, as well as helping the server to serve static files like CSS, JS, and images.
 *
 * Generated by ChatGPT -4o
 *
 * @author https://chat.openai.com/
 */
// Middleware to parse JSON
app.use(express.json());

// Middleware to serve static files (CSS, JS, images)
app.use(express.static("public"));

// Middleware to use favicon
// app.use(express.favicon(__dirname + '/public/images/favicon.png'));
app.use(favicon(path.join(__dirname, "public", "images", "favicon.png")));

// Middleware to parse URL-encoded form data
app.use(express.urlencoded({ extended: true }));

// Middleware for sessions
app.use(
  session({
    secret: process.env.SECRETKEY,
    resave: false,
    saveUninitialized: true,
    cookie: { maxAge: 86400000 },
  })
);
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Database connection
mongoose
  .connect(process.env.MONGO_STRING, {
    /**
     * Setting's for database connection
     * With these settings, we can avoid deprecation warnings and ensure a more stable connection.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    useNewUrlParser: true,
    useUnifiedTopology: true,
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  })
  .then(() => {
    console.log("Connected to database successfully!");
  })
  .catch((err) => {
    console.log("Error connecting to database:", err.message);
  });

/** This is the schema for users, it acts as a template for models to use when creating new documents in the database.
 *  Transaction ID's are included in the user schema.
 *  Pets are included in the user schema.
 */
const userSchema = new mongoose.Schema({
  username: String,
  password: String,
  categories: Array,
  balance: Number,
  transactions: Array,
  // Generated by ChatGPT -4o
  activeAchievements: [
    { type: mongoose.Schema.Types.ObjectId, ref: "achievements" },
  ],
  inactiveAchievements: [
    { type: mongoose.Schema.Types.ObjectId, ref: "achievements" },
  ],
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  inventory: Array,
  pet: {
    base: String,
    item: String,
    happiness: Number,
    lastPetted: Date,
  },
  date: Date,
  previousDate: Date,
  budget: {
    weekly: Number,
    monthly: Number,
  },
  coins: Number,
  lastLogin: Date,
  loginStreak: Number,
});

/**
 * This is the schema for transactions, it acts as a template for models to use when creating new documents in the database.
 * Transactions are tied to users in there user schema by thier model ID.
 * The server automatically adds the transaction ID to the user schema when a new transaction is created.
 */
const transactionSchema = new mongoose.Schema({
  name: String,
  category: String,
  date: Date,
  amount: Number,
  comments: String,
  type: String,
});

/**
 * This is the schema for achievements, it acts as a template for models to use when creating new documents in the database.
 * Achievements are tied to users in there user schema by thier model ID.
 * The server automatically adds the achievement ID to the user schema when a new achievement is created.
 */
const achievementSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "users",
  },
  type: String,
  description: String,
  progress: Number,
  target: Number,
  date: Date,
  previousDate: Date,
  completed: Boolean,
  reward: Number,
});

// Here we create a model for the achievement schema, this will be used to make our collection in the database.
const achievements = mongoose.model("achievements", achievementSchema);

// Here we create a model for the user schema, this will be used to make our collection in the database.
const users = mongoose.model("users", userSchema);

// Here we create a model for the transaction schema, this will be used to make our collection in the database.
const transactions = mongoose.model("transactions", transactionSchema);

// Import the routes after models are registered
const achievementsRoutes = require("./routes/achievements");
app.use("/achievements", achievementsRoutes);

// Redirect / to /login, in the event that only the base URL is entered in the browser.
// This redirects the user to the home page if they are logged in.
app.get("/", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.redirect("/index");
});

// Here the server will recognise that the server is requested with the /login URL and will render the login file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/login", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("login", { message: "" });
});

// happiness decay
async function happinessDecay(pet) {
  const now = new Date();
  const lastPetted = new Date(pet.lastPetted);

  const minuteDifference = now - lastPetted;
  const hourDifference = Math.floor(minuteDifference / 3600000);
  const newHappiness = Math.max(0, pet.happiness - hourDifference);

  // Cap off at 100
  const happiness = Math.min(100, newHappiness);

  return happiness;
}

app.get("/game", async (request, result) => {
  if (!request.session.uid) {
    return result.redirect("/login");
  }
  request.session.joke = "";
  try {
    const user = await users.findById(request.session.uid);
    const pet = user.pet;

    // Update the database
    const happiness = await happinessDecay(pet);
    await users.findByIdAndUpdate(request.session.uid, {
      "pet.happiness": happiness,
    });
    pet.happiness = happiness;

    // Tracking multi-day happiness for ami_happiness achievement
    const amiHappinessAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "ami_happiness",
      completed: false,
    });

    if (amiHappinessAchievement && pet.happiness >= 80) {
      const lastDate = new Date(amiHappinessAchievement.previousDate);
      const now = new Date();

      // New day check
      const isNewDay =
        now.getFullYear() !== lastDate.getFullYear() ||
        now.getMonth() !== lastDate.getMonth() ||
        now.getDate() !== lastDate.getDate();

      // If new day and happiness above 80, increment progress
      if (
        isNewDay &&
        amiHappinessAchievement.progress < amiHappinessAchievement.target
      ) {
        amiHappinessAchievement.progress += 1;
        amiHappinessAchievement.previousDate = now;
        await amiHappinessAchievement.save();
      }
    }

    console.log("Fetched pet data:", pet);
    result.render("game", { pet });
  } catch (err) {
    console.log("Error rendering pet info:", err.message);
    result.status(500).send("Internal server error");
  }
});

app.get("/user/pet", async (request, result) => {
  if (!request.session.uid) return result.status(401).send("Unauthorized");
  try {
    const user = await users.findById(request.session.uid);
    result.json(user.pet);
  } catch (err) {
    result.status(500).send("Error fetching pet data");
  }
});

app.post("/user/pet", async (request, result) => {
  if (!request.session.uid) {
    return result.status(401).send("Unauthorized");
  }

  request.session.joke = "";
  try {
    const user = await users.findById(request.session.uid);
    // Update the pet with new values
    user.pet.base = request.body.base;
    user.pet.item = request.body.item;
    user.pet.happiness = request.body.happiness;

    // Set lastPetted
    user.pet.lastPetted = new Date();

    // Check for pet_ami achievement
    const petAmiAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "pet_ami",
      completed: false,
    });

    // If pet after accepting the achievement
    if (
      petAmiAchievement &&
      petAmiAchievement.progress < petAmiAchievement.target
    ) {
      // Then increment achievement progress
      petAmiAchievement.progress += 1;
      await petAmiAchievement.save();
    }

    await user.save();
    result.json(user.pet);
  } catch (err) {
    console.log("Error updating pet info:", err.message);
    result.status(500).send("Internal server error");
  }
});

app.get("/add-expense", (req, res) => {
  res.render("partials/expense_log");
});

// Check if the user stayed within their weekly budget over the last 7 days (starting from when 'weekly_budget' achievement was activated)
async function checkWeeklyBudgetAchievement(user) {
  // Find user's active 'weekly_budget' achievement that is not completed
  const achievement = await achievements.findOne({
    _id: { $in: user.activeAchievements },
    type: "weekly_budget",
    completed: false,
  });

  // Stop if user does not have this achievement
  if (!achievement) {
    return;
  }

  // Get start date
  const start = new Date(achievement.date);
  // Get current date
  const now = new Date();

  // Fix timezone
  now.setMinutes(now.getMinutes() + now.getTimezoneOffset());

  // Calculate full days since the achievement activated
  const daysSince = Math.floor((now - start) / (1000 * 60 * 60 * 24));
  // If les than 7 days, return
  if (daysSince < 7) return;

  // Define end of 7 day period
  const end = new Date(start);
  end.setDate(start.getDate() + 7);
  end.setHours(23, 59, 59, 999);

  // Get all user expenses from 7 day period
  const expenses = await mongoose.model("transactions").find({
    _id: { $in: user.transactions },
    type: "expense",
    date: { $gte: start, $lte: end },
  });

  // Calculate total amount from 7 day period
  const totalSpent = expenses.reduce((sum, t) => sum + t.amount, 0);

  // If user spent <= their weekly budget (and their budget is set > 0)
  if (totalSpent <= user.budget.weekly && user.budget.weekly > 0) {
    // Increment achievement progress by 1
    const progress = achievement.progress;
    const target = achievement.target;

    if (progress < target) {
      achievement.progress += 1;
      await achievement.save();
    }
  }
}

// Check if the user stayed within their monthly budget over the last 30 days (from achievement start date)
async function checkMonthlyBudgetAchievement(user) {
  const achievement = await achievements.findOne({
    _id: { $in: user.activeAchievements },
    type: "monthly_budget",
    completed: false,
  });

  if (!achievement) {
    return;
  }

  const start = new Date(achievement.date);
  const now = new Date();

  // Fix timezone
  now.setMinutes(now.getMinutes() + now.getTimezoneOffset());

  const daysSince = Math.floor((now - start) / (1000 * 60 * 60 * 24));
  if (daysSince < 30) return;

  const end = new Date(start);
  end.setDate(start.getDate() + 30);
  end.setHours(23, 59, 59, 999);

  const expenses = await transactions.find({
    _id: { $in: user.transactions },
    type: "expense",
    date: { $gte: start, $lte: end },
  });

  const totalSpent = expenses.reduce((sum, t) => sum + t.amount, 0);

  if (totalSpent <= user.budget.monthly && user.budget.monthly > 0) {
    const progress = achievement.progress;
    const target = achievement.target;
    if (progress < target) {
      achievement.progress += 1;
      await achievement.save();
    }
  }
}

// Check if user bought coffee for coffee achievement
async function checkCoffeeAchievement(user) {
  // Find user's active 'coffee' achievement that is not completed
  const achievement = await achievements.findOne({
    _id: { $in: user.activeAchievements },
    type: "coffee",
    completed: false,
  });

  console.log(achievement, "this is the achievement!");

  // Stop if user does not have this achievement
  if (!achievement) return;

  // Get current date
  const now = new Date();
  // Get date last checked for achievement
  const lastCheck = new Date(achievement.previousDate);
  // Check if it's a new day
  const isNewDay =
    now.getFullYear() !== lastCheck.getFullYear() ||
    now.getMonth() !== lastCheck.getMonth() ||
    now.getDate() !== lastCheck.getDate();

  console.log("its a new day... ", isNewDay);

  // Skip if already checked today
  if (!isNewDay) return;

  // Set up time range for day
  const start = new Date(lastCheck);
  start.setHours(0, 0, 0, 0);
  const end = new Date(lastCheck);
  end.setHours(23, 59, 59, 999);

  // Search for any expense with name 'coffee'
  const coffee = await transactions.findOne({
    _id: { $in: user.transactions },
    type: "expense",
    // Case insensitive
    name: /coffee/i,
    date: { $gte: start, $lte: end },
  });

  // If no coffee was bought today and the achievement is not done yet
  if (!coffee && achievement.progress < achievement.target) {
    // Increment progress
    achievement.progress += 1;
    // Set today as last checked date
    achievement.previousDate = now;
    await achievement.save();

    // If coffee was bought today, don't increment progress
  } else if (coffee) {
    // Set today as last checked date
    achievement.previousDate = now;
    await achievement.save();
  }
}

// PROFILE PAGE
// Fetch user info from mongoDB
// app.use('/scripts', express.static(__dirname + '/scripts'));
app.get("/profile", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    req.session.joke = "";
    res.render("profile", { user });
  } catch (err) {
    console.error("Error fetching user:", err);
    res.status(500).send("Internal Server Error");
  }
});

// Post changes to mongoDB
app.post("/profile/update", async (req, res) => {
  if (!req.session.uid) return res.status(401).json({ error: "Unauthorized" });

  const { username, password, weekly, monthly } = req.body;

  try {
    const update = {
      username,
      budget: {
        weekly: Number(weekly),
        monthly: Number(monthly),
      },
    };

    // Only hash password if it's provided and not blank
    if (password && password.trim() !== "") {
      const hashedPassword = await bcrypt.hash(password, 10);
      update.password = hashedPassword;
    }

    // Only update the selected field
    const updateOps = {};

    if (username) updateOps["username"] = username;
    if (password && password.trim() !== "") {
      const hashedPassword = await bcrypt.hash(password, 10);
      updateOps["password"] = hashedPassword;
    }
    if (weekly !== undefined) updateOps["budget.weekly"] = Number(weekly);
    if (monthly !== undefined) updateOps["budget.monthly"] = Number(monthly);

    // Update user with new profile values
    await users.findByIdAndUpdate(req.session.uid, { $set: updateOps });

    // Fetch updated user
    const user = await users.findById(req.session.uid);

    // Track "weekly" progress for "Start by setting your weekly budget" achievement
    if (weekly !== undefined && Number(weekly) > 0) {
      const weeklyAchievement = await achievements.findOne({
        _id: { $in: user.activeAchievements },
        type: "weekly",
        completed: false,
      });

      // If the 'weekly' achievement type exists for the user, and it hasn’t reached its target yet, then increase its progress by 1
      if (
        weeklyAchievement &&
        weeklyAchievement.progress < weeklyAchievement.target
      ) {
        weeklyAchievement.progress += 1;
        await weeklyAchievement.save();
      }
    }

    // Track "monthly" progress for "Set your monthly budget" achievement
    if (monthly !== undefined && Number(monthly) > 0) {
      const monthlyAchievement = await achievements.findOne({
        _id: { $in: user.activeAchievements },
        type: "monthly",
        completed: false,
      });
      // If the 'monthly' achievement type exists for the user, and it hasn’t reached its target yet, then increase its progress by 1
      if (
        monthlyAchievement &&
        monthlyAchievement.progress < monthlyAchievement.target
      ) {
        monthlyAchievement.progress += 1;
        await monthlyAchievement.save();
      }
    }

    res.status(200).json({ message: "Profile updated" });
  } catch (err) {
    console.error("Update error:", err.message);
    res.status(500).json({ error: "Database update failed" });
  }
});

// Here the server will recognise that the server is requested with the /home URL and will render the home file.
// If the user is not logged in, they will be redirected to the login page.
app.get("/home", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    const userTransactions = await transactions.find({
      _id: { $in: user.transactions },
    });

    // Check for weekly_budget achievement
    await checkWeeklyBudgetAchievement(user);
    // Check for monthly_budget achievement
    await checkMonthlyBudgetAchievement(user);
    // Check for coffee achievement
    await checkCoffeeAchievement(user);
    const now = new Date();

    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay() + 1); // Monday

    const spentThisWeek = userTransactions
      .filter((t) => t.type === "expense" && t.date >= startOfWeek)
      .reduce((sum, t) => sum + t.amount, 0);

    const spentThisMonth = userTransactions
      .filter(
        (t) =>
          t.type === "expense" &&
          t.date >= new Date(now.getFullYear(), now.getMonth(), 1)
      )
      .reduce((sum, t) => sum + t.amount, 0);

    const weeklyBudget = user.budget.weekly || 1;
    const monthlyBudget = user.budget.monthly || 1;

    const weeklyPercent = Math.min(100, (spentThisWeek / weeklyBudget) * 100);
    const monthlyPercent = Math.min(
      100,
      (spentThisMonth / monthlyBudget) * 100
    );

    const totalIncome = userTransactions
      .filter((t) => t.type === "income")
      .reduce((sum, t) => sum + t.amount, 0);
    const totalExpenses = userTransactions
      .filter((t) => t.type === "expense")
      .reduce((sum, t) => sum + t.amount, 0);
    const balance = totalIncome - totalExpenses;

    // Sorts the transactions and slices out the most recent 5 to send to the view
    const topFive = userTransactions
      .sort((a, b) => new Date(b.date) - new Date(a.date))
      .slice(0, 5);

    res.render("home", {
      username: req.session.username,
      totalIncome,
      totalExpenses,
      balance,
      expenses: userTransactions,
      five: topFive,
      joke: req.session.joke,
      spentThisWeek,
      spentThisMonth,
      weeklyPercent,
      monthlyPercent,
      weeklyBudget,
      monthlyBudget,
    });
  } catch (err) {
    console.error("Error loading home:", err.message);
    res.status(500).send("Internal Server Error");
  }
});

// Here the server will recognise that the server is requested with the /index URL and will render the index file.
// If the user is already logged in, they will be redirected to the home page.
app.get("/index", (request, result) => {
  if (request.session.uid) {
    return result.redirect("/home");
  }
  result.render("index");
});

/**
 * Sign's up a new user.
 * If the user already exists, an error message is returned.
 * Uses bcrypt to hash the password before saving it to the database.
 * Add's five default achievements to the user, storing the id's in an array in user and adding the achievements to the database directly.
 * The new user is saved to the database and their uid is stored in the session.
 * The user is created from the mongoDB users model.
 */
app.post("/auth/register", async (req, res) => {
  try {
    const username = req.body.username;
    const password = req.body.password;
    const existingUser = await users.findOne({ username });
    if (existingUser) {
      return res.render("login", {
        message: "User already exists, please make another username!",
      });
    }
    // Active Achievements
    const defaultActiveAchievements = [
      {
        type: "welcome",
        description: "Welcome to EconAmi!",
        progress: 1,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 5,
      },
      {
        type: "add_achievement",
        description:
          "Select an inactive achievement that you want to work on (max of 4 active achievements at a time!)",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
    ];

    // Inactive achievements
    const defaultInactiveAchievements = [
      {
        type: "weekly",
        description:
          "Start by setting your weekly budget from your profile page.",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "monthly",
        description: "Set your monthly budget from your profile page.",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "pet_ami",
        description: "Introduce yourself to Ami. Go ahead and pet Ami!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 5,
      },
      {
        type: "input_expense",
        description: "Input 3 expenses on the home page.",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "weekly_budget",
        description: "Hit your weekly budget goal!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 200,
      },
      {
        type: "monthly_budget",
        description: "Achieve your monthly budget goal!",
        progress: 0,
        target: 1,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 200,
      },
      {
        type: "ami_happiness",
        description: "Keep Ami's happiness above 80 for 3 days.",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
      {
        type: "coffee",
        description:
          "Brew your own coffee at home for 5 days. (Don't buy coffee outside!)",
        progress: 0,
        target: 5,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 50,
      },
      {
        type: "login",
        description: "Keep a daily login streak for 3 days!",
        progress: 0,
        target: 3,
        date: new Date(),
        previousDate: new Date(),
        completed: false,
        reward: 10,
      },
    ];

    const activeAchievements = [];
    const inactiveAchievements = [];

    /**
     * This is used to set the date to the correct timezone.
     * Without this, the date will be set to UTC time.
     * Generated by ChatGPT -4o
     *
     * @author https://chat.openai.com/
     */
    for (let i = 0; i < defaultActiveAchievements.length; i++) {
      defaultActiveAchievements[i].date.setMinutes(
        defaultActiveAchievements[i].date.getMinutes() +
          defaultActiveAchievements[i].date.getTimezoneOffset()
      );
      defaultActiveAchievements[i].previousDate.setMinutes(
        defaultActiveAchievements[i].previousDate.getMinutes() +
          defaultActiveAchievements[i].previousDate.getTimezoneOffset()
      );
    }

    for (const achievementData of defaultInactiveAchievements) {
      achievementData.date.setMinutes(
        achievementData.date.getMinutes() +
          achievementData.date.getTimezoneOffset()
      );
      achievementData.previousDate.setMinutes(
        achievementData.previousDate.getMinutes() +
          achievementData.previousDate.getTimezoneOffset()
      );

      const newAchievement = new achievements({
        ...achievementData,
        userId: req.session.uid,
      });
      await newAchievement.save();
      inactiveAchievements.push(newAchievement._id);
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    for (const achievementData of defaultActiveAchievements) {
      achievementData.date.setMinutes(
        achievementData.date.getMinutes() +
          achievementData.date.getTimezoneOffset()
      );
      achievementData.previousDate.setMinutes(
        achievementData.previousDate.getMinutes() +
          achievementData.previousDate.getTimezoneOffset()
      );

      const newAchievement = new achievements({
        ...achievementData,
        userId: req.session.uid,
      });
      await newAchievement.save();
      activeAchievements.push(newAchievement._id);
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new users({
      username,
      password: hashedPassword,
      categories: [
        "Income",
        "Rent",
        "Groceries",
        "Transportation",
        "Dining Out",
        "Entertainment",
        "Health",
        "Insurance",
        "Education",
        "Pets",
      ],
      balance: 0,
      transactions: [],
      activeAchievements,
      inactiveAchievements,
      budget: {
        weekly: 0,
        monthly: 0,
      },
      inventory: [],
      pet: {
        base: "white",
        item: "",
        happiness: 80,
        lastPetted: new Date(),
      },
      date: new Date(),
      previousDate: new Date(),
      coins: 0,
      lastLogin: new Date(),
      loginStreak: 1,
    });
    await newUser.save();
    req.session.uid = newUser._id;
    req.session.username = newUser.username;
    req.session.joke = null;
    res.redirect("/home");
  } catch (err) {
    console.log("Error during registration:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// get user achievements data for navbar notification
app.get("/navbar", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users
      .findById(request.session.uid)
      .populate("activeAchievements");
    console.log(user);
    result.json({
      achievements: user.activeAchievements,
    });
  } catch (err) {
    console.log("Error fetching achievements data:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Log's in a user.
 * If the user does not exist, an error message is returned.
 * The password is compared to the hashed password in the database using bcrypt.
 * If the password is correct, the user's uid is stored in the session.
 * If the password is incorrect, an error message is returned.
 * The user is redirected to the home page upon successful login.
 */
app.post("/auth/login", async (request, result) => {
  try {
    const { username, password } = request.body;
    const user = await users.findOne({ username });
    if (!user) {
      return result.render("login", {
        message: "Please input a valid username and password!",
      });
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return result.render("login", {
        message: "Wrong password please try again!",
      });
    }

    // Tracking for login streak achievement
    // Get today's date
    const today = new Date();

    // Fix timezone
    today.setMinutes(today.getMinutes() + today.getTimezoneOffset());

    // Get user's last login date
    const lastLoginDate = new Date(user.lastLogin);
    // Calculate the time difference between the two dates
    const diffTime = today - lastLoginDate;
    // Convert the time difference into days
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    // If user logged in one day after their last login, then increment streak by 1
    if (diffDays === 1) {
      user.loginStreak = (user.loginStreak || 1) + 1;
      // Else if reset streak back to 1
    } else if (diffDays > 1) {
      user.loginStreak = 1;
    }

    // Update lastLogin date
    user.lastLogin = today;

    // Find user's login achievement
    const loginAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "login",
      completed: false,
    });

    // If achievement exists and progress is below target, then update progress to match streak
    if (
      loginAchievement &&
      user.loginStreak > loginAchievement.progress &&
      loginAchievement.progress < loginAchievement.target
    ) {
      loginAchievement.progress = user.loginStreak;
      await loginAchievement.save();
    }
    await user.save();

    request.session.uid = user._id;
    request.session.username = user.username;
    request.session.joke = null;
    result.redirect("/home");
  } catch (err) {
    console.log("Error during login:", err.message);
    result.status(500).json({ error: err.message });
  }
});

/**
 * Log's out a user.
 * The session is destroyed and the user is redirected to the login page.
 * If there is an error during logout, an error message is returned.
 * The user is redirected to the login page upon successful logout.
 */
app.post("/auth/logout", (request, result) => {
  request.session.destroy((err) => {
    if (err) {
      return result
        .status(500)
        .json({ error: "Failed to log out:" + err.message });
    }
    result.redirect("/login");
  });
});

/**
 * Add's a new transaction.
 * The transaction is created from the mongoDB transactions model.
 * The transaction is saved to the database and the user's transactions array is updated automatically with the models ID.
 */
app.post("/transaction/add", (request, result) => {
  const name = request.body.name;
  const category = request.body.category;
  const date = new Date(request.body.date);
  /**
   * This is used to set the date to the correct timezone.
   * Without this, the date will be set to UTC time.
   * Generated by ChatGPT -4o
   *
   * @author https://chat.openai.com/
   */
  date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  const amount = request.body.amount;
  const comments = request.body.comments;
  const newTransaction = new transactions({
    name,
    category,
    date,
    amount,
    comments,
  });
  newTransaction
    .save()
    .then(() => {
      return users.findByIdAndUpdate(request.session.uid, {
        $push: { transactions: newTransaction._id },
      });
    })
    .then(() => {
      console.log(
        "Transaction added successfully to: ",
        request.session.uid,
        "! Details: ",
        newTransaction
      );
      result.redirect("/home");
    })
    .catch((err) => {
      console.log("Error adding transaction:", err.message);
      result.status(500).json({ error: "Internal server error" });
    });
});

/**
 * Fetches all transactions for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are identified and populated in a new temporary object to deliver while rendering the page.
 */
app.get("/transactions", async (req, res) => {
  try {
    if (!req.session.uid) {
      return res.redirect("/login");
    }

    const user = await users.findById(req.session.uid);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const { type, category, sort } = req.query;
    const filter = { _id: { $in: user.transactions } };
    if (type) filter.type = type;
    if (category) filter.category = category;

    let sortOption = { date: -1, _id: -1 };
    if (sort === "date_asc") sortOption = { date: 1 };
    else if (sort === "amount_desc") sortOption = { amount: -1 };
    else if (sort === "amount_asc") sortOption = { amount: 1 };

    const transactionsList = await transactions.find(filter).sort(sortOption);
    console.log("Fetched Transactions:", transactionsList);
    req.session.joke = "";
    // calculating current month's expense here
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const currentMonthExpenses = await transactions.find({
      _id: { $in: user.transactions },
      type: "expense",
      date: { $gte: startOfMonth, $lte: now },
    });
    const spentThisMonth = (currentMonthExpenses || []).reduce(
      (sum, t) => sum + t.amount,
      0
    );
    const percent = Math.min((spentThisMonth / user.budget.monthly) * 100, 100);

    let colorClass = "text-green-600";
    if (percent >= 90) {
      colorClass = "text-red-600";
    } else if (percent >= 50) {
      colorClass = "text-yellow-600";
    }

    res.render("transactions", {
      transactions: transactionsList,
      type: type || "",
      category: category || "",
      sort: sort || "date_desc",
      selectedType: type || "",
      selectedCategory: category || "",
      selectedSort: sort || "date_desc",
      budget: user.budget,
      spentThisMonth,
      percent,
      colorClass,
    });
  } catch (err) {
    console.error("Error fetching /transactions route:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Fetches all transactions for the logged-in user. Dose not render a page.
 * Uses the user's ID stored in the session to find the user in the database where the transaction id's are stored.
 * Transactions are sent to the client as JSON.
 */
app.post("/transactions/fetch", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    const transactionsList = await transactions.find({
      _id: { $in: user.transactions },
    });
    console.log("Fetched Transactions:", transactionsList);
    result.json({ transactions: transactionsList });
  } catch (err) {
    console.log("Error fetching transactions:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});




app.get("/transactions/chart-data", async (req, res) => {
  if (!req.session.uid) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  try {
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const user = await users.findById(req.session.uid);
    const allTransactions = await transactions.find({
      _id: { $in: user.transactions },
      type: "expense",
      date: { $gte: startOfMonth, $lte: now },
    });

    const categoryTotals = {};
    const monthlyTotals = {};
    const weeklyTotals = {};
    const weeklyCategoryTotal = {}; // NEW

    const startOfWeek = new Date(now);
    startOfWeek.setDate(now.getDate() - now.getDay() + 1); // Monday
    startOfWeek.setHours(0, 0, 0, 0);

    allTransactions.forEach((t) => {
      // Monthly & category processing
      categoryTotals[t.category] = (categoryTotals[t.category] || 0) + t.amount;

      const dateObj = new Date(t.date);
      const month = dateObj.toLocaleString("default", { month: "short" });
      monthlyTotals[month] = (monthlyTotals[month] || 0) + t.amount;

      const day = dateObj.getDay();
      const diffToMonday = (day === 0 ? -6 : 1) - day;
      const monday = new Date(dateObj);
      monday.setDate(dateObj.getDate() + diffToMonday);
      const weekKey = `Week of ${monday.toISOString().slice(0, 10)}`;
      weeklyTotals[weekKey] = (weeklyTotals[weekKey] || 0) + t.amount;

      // Weekly category breakdown for this week's donut chart
      if (dateObj >= startOfWeek && dateObj <= now) {
        weeklyCategoryTotal[t.category] =
          (weeklyCategoryTotal[t.category] || 0) + t.amount;
      }
    });


    // Sort monthly totals by calendar month order
    const monthOrder = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    const sortedMonthly = Object.entries(monthlyTotals).sort(
      (a, b) => monthOrder.indexOf(a[0]) - monthOrder.indexOf(b[0])
    );
    const monthlyLabels = sortedMonthly.map(([label]) => label);
    const monthlyValues = sortedMonthly.map(([, value]) => value);

    // Sort weekly totals by week number
    const sortedWeekly = Object.entries(weeklyTotals).sort(
      (a, b) =>
        new Date(a[0].replace("Week of ", "")) -
        new Date(b[0].replace("Week of ", ""))
    );

    const weeklyLabels = sortedWeekly.map(([label]) => label);
    const weeklyValues = sortedWeekly.map(([, value]) => value);

    res.json({
      category: {
        labels: Object.keys(categoryTotals),
        values: Object.values(categoryTotals),
      },
      monthly: {
        labels: monthlyLabels,
        values: monthlyValues,
      },
      weekly: {
        labels: weeklyLabels,
        values: weeklyValues,
      },
      weeklyCategory: weeklyCategoryTotal,
    });
  } catch (err) {
    console.error("Error fetching chart data:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Fetches all categories for the logged-in user.
 * Uses the user's ID stored in the session to find the user in the database where the categories are stored.
 * Since all categories are already listed in one place we just return the users categories array.
 */
app.post("/categories", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    if (!user) {
      return result.status(404).json({ error: "User not found" });
    }
    console.log("Fetched Categories:", user.categories);
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error fetching categories:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Add's a new category to the user's categories array.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/add", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories.push(category);
    await user.save();
    console.log(
      "Category ",
      category,
      " added successfully to user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error adding category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

/**
 * Delete's a category from the user's categories array.
 * Filters through and allows all categories that are not equal to the one being deleted.
 * First checks if the user is logged in by checking the session.
 * Sends the new array of categories back to the view.
 */
app.post("/categories/remove", async (request, result) => {
  try {
    const category = request.body.category;
    if (!request.session.uid) {
      return result.status(404).json({ error: "User not found" });
    }
    const user = await users.findById(request.session.uid);
    user.categories = user.categories.filter((cat) => cat !== category);
    await user.save();
    console.log(
      "Category ",
      category,
      " deleted successfully from user:",
      request.session.uid
    );
    result.json({ categories: user.categories });
  } catch (err) {
    console.log("Error deleting category:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

app.get("/weather", async (req, res) => {
  const { lat, lon } = req.query;
  const apiKey = process.env.WEATHER_API_KEY;

  try {
    const response = await axios.get(
      `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}`
    );
    res.json(response.data);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch weather data" });
  }
});

/**
 * Fetches the user's budget's from the database.
 * Uses the user's ID stored in the session to find the user in the database where the budget's are stored.
 * The budget's are identified and populated in a new temporary object to deliver to the view.
 */
app.post("/budget", async (request, result) => {
  try {
    if (!request.session.uid) {
      return result.redirect("/login");
    }
    const user = await users.findById(request.session.uid);
    console.log("Fetched Budget:", user.budget);
    result.json({ budget: user.budget });
  } catch (err) {
    console.log("Error fetching budget:", err.message);
    result.status(500).json({ error: "Internal server error" });
  }
});

// Delete a transaction
// Routed to home page
app.post("/delete-expense/:id", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    await transactions.findByIdAndDelete(req.params.id);
    await users.findByIdAndUpdate(req.session.uid, {
      $pull: { transactions: req.params.id },
    });

    console.log(`Transaction deleted successfully.`);
    res.redirect("/home");
  } catch (error) {
    console.error("Error deleting transaction:", error.message);
    res.status(500).send("Error deleting transaction");
  }
});

// Handle form submission and save to MongoDB
app.post("/add-expense", async (req, res) => {
  if (!req.session.uid) {
    res.redirect("/login");
  }

  const user = await users.findById(req.session.uid);
  const { type, name, amount, category, date } = req.body;

  try {
    const newTransaction = new transactions({
      type,
      name,
      amount,
      category,
      date: new Date(date),
    });

    await newTransaction.save();

    user.transactions.push(newTransaction._id);
    await user.save();

    // Track progress for the "input_expense" achievement
    const inputExpenseAchievement = await achievements.findOne({
      _id: { $in: user.activeAchievements },
      type: "input_expense",
      completed: false,
    });

    if (
      inputExpenseAchievement &&
      inputExpenseAchievement.progress < inputExpenseAchievement.target
    ) {
      inputExpenseAchievement.progress += 1;
      await inputExpenseAchievement.save();
    }

    res.redirect("/home");
  } catch (err) {
    console.error("Error saving transaction: ", err.message);
    res.status(500).send("Error saving transaction");
  }
});

/**
 * Requests a joke from the OpenAI API using the axios library.
 * The request is plain text as if your talking to the chatbot on it's website.
 * The following prompt was used to acheive our project's goal.
 * Roles user and assistant are their way of identifing who is talking.
 * The bearer is the person who owns the api giving you their key.
 * The model is the version of the gpt we are using. (currently the cheapest to use for the best randomness)
 * This script was made by modifying the origional code from OpenAI... as such.
 *
 * @author OpenAI
 */
app.post("/joke", async (req, res) => {
  try {
    const aiResponse = await axios.post(
      "https://api.openai.com/v1/chat/completions",
      {
        model: "gpt-4o",
        temperature: 0.9,
        presence_penalty: 0.6,
        frequency_penalty: 0.4,
        messages: [
          {
            role: "user",
            content:
              "Make a unique, short, school-friendly joke in 1 - 2 sentences. Be creative so you avoid repeating earlier jokes.",
          },
        ],
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.chatGPT}`,
        },
      }
    );
    req.session.joke = aiResponse.data.choices[0].message.content;
    console.log("Fetched Joke:", req.session.joke);
    res.redirect("/home");
  } catch (error) {
    console.error("Error fetching joke:", error.message);
    res.status(500).send("Error fetching joke");
  }
});

/**
 * This is the route for the post /pet URL.
 * It reads the pet data based on uid stored in the session.
 * And hands it to the view, In json format.
 */
app.post("/pet", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    console.log("Fetched Pet:", user.pet);
    res.json({ pet: user.pet });
  } catch (err) {
    console.log("Error fetching pet:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * This is the route for the post /pet/update URL.
 * It updates the pet data based on uid stored in the session, and the data sent in the request body.
 * It returns the new pet data in json format, after updating it in the database.
 */
app.post("/pet/update", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    const { base, item, happiness } = req.body;
    user.pet.base = base;
    user.pet.item = item;
    user.pet.happiness = happiness;
    await user.save();
    console.log("Updated Pet:", user.pet);
    res.json({ pet: user.pet });
  } catch (err) {
    console.log("Error updating pet:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * This is the route for reading inventory and coins.
 * It fetches the user's information using the uid stored in the session.
 * The data is sent to the view in JSON format.
 */
app.post("/inventory", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    res.json({ inventory: user.inventory, coins: user.coins });
  } catch (err) {
    console.error("Error fetching inventory:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * This is the route for updating inventory and coins.
 * It fetches the user using the uid stored in the session.
 * It updates the user's inventory and coin values with the data in request body.
 * The updated inventory and coins are sent to the view in JSON format.
 */
app.post("/inventory/update", async (req, res) => {
  if (!req.session.uid) {
    return res.redirect("/login");
  }
  try {
    const user = await users.findById(req.session.uid);
    const { inventory, coins } = req.body;
    user.inventory = inventory;
    user.coins = coins;
    await user.save();
    console.log("Updated Inventory:", user.inventory);
    console.log("Updated Coins:", user.coins);
    res.json({ inventory: user.inventory, coins: user.coins });
  } catch (err) {
    console.error("Error updating inventory:", err.message);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Start's the server and listens on the specified port.
// The port is set to 3000 by default.
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
